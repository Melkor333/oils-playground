#!/usr/bin/env ysh

var DEBUG = false
proc debug {
  if (DEBUG) {
    echo DEBUG - @[ARGV]
  }
}
proc debug-val (name;val) {
  if (DEBUG) {
    echo DEBUG $name - $(pp value (val))
  }
}
func mergeFacts (dst, src) {
  debug-val src (src)
  debug-val dst (dst)
  for fact in (src) {
    if (dst=>indexOf(fact) === -1) {
      call dst->append(fact)
    }
  }
  debug-val src (src)
  debug-val dst (dst)
}

# a list of facts, against which the current needs to be checked
var facts = []
var rules = []

# a list of predicates and they're current choices
var current_set = {}

proc - {
  var predicate = ARGV[0]
  assert [len(ARGV) > 1]
  if (facts=>indexOf(ARGV) !== null) {
    call facts->append(ARGV)
  } else {
    setglobal facts = [ARGV]
  }
}
proc WHEN {
  var pred = []
  var conditions = [] # [['edge', 'Y', 'X'], ... ]
  var truths = []
  for i, arg in (ARGV) {
    if (arg === 'THEN') {
      var point = i+1
      break
    }
    if (arg === 'AND') {
      call conditions->append(pred)
      setvar pred = []
      continue
    }
    call pred->append(arg)
  }

  call conditions->append(pred)
  setvar pred = []
  for i, arg in (ARGV[point:]) {
    if (arg === 'AND') {
      call truths->append(pred)
      setvar pred = []
      continue
    }
    call pred->append(arg)
  }
  call truths->append(pred)
  call rules->append([conditions, truths])
  debug-val " rules" (rules)
}

# cond -> Condition to be evaluated [[[COND1][COND2]], [[FACT1],[FACT2]]]
# facts -> Existing facts [[FACT],[FACT],...]
# pred -> List of already defined predicates to meet condition
func evalConditions(conditions, truths, facts,...args) {
  var placeholders = {}
  var param
  debug-val conditions (conditions)
  debug-val args (args)
  debug-val facts (facts)
  for num_pred, arg in (args) {
    assert [len(conditions[num_pred]) === len(arg)] # args need to match
    debug-val rule (conditions[num_pred])
    # check conditions/fill in placeholders.
    # TODO: pass down (by copy)
    for i, val in (arg[1:]) {
      setvar param = conditions[num_pred][i+1]
      debug-val placeholders (placeholders)
      debug-val val (val)
      debug-val param (param)
      if (placeholders=>get(param) is not null) {
        if (val !== placeholders[param]) {
      	  debug doesnt match:
	        debug-val "condition" (conditions[num_pred])
	        debug-val "val" (val)
          debug-val 'placeholders' (placeholders)
	        return ([])
      	}
      } else {
        setvar placeholders[param] = val
     	}
    }
  }
  var new_facts = []
  # Not all conditions are met yet
  if (len(args) < len(conditions)) {
    # Loop over all facts we have for the args. Use it as argument
    for f in (facts) {
      # only use fact if it matches predicate
      # of next unmet condition
      if (f[0] !== conditions[len(args)][0]) {
        continue
      }
      debug-val "new arg" ([f])
      call mergeFacts(new_facts, evalConditions(conditions, truths,facts, ...args, f))
      debug-val 'new_facts after merge' (new_facts)

    }
  } else {
    #echo 'add placeholders!'
    debug-val placeholders (placeholders)
    debug-val truths (truths)
    var fact
    for truth in (truths) {
      debug-val "truth" (truth)
      setvar fact = [truth[0]]
      for param in (truth[1:]) {
        # TODO: Only use placeholder if capitalized
        call fact->append(placeholders[param])
      }
      debug-val "new fact" (fact)
      call new_facts->append(fact)
    }
  }
  debug-val "new facts" (new_facts)
  return (new_facts)
}

source $[ARGV[0]]
debug-val 'all facts' (facts)
for rule in (rules) {
  # todo facts per choice!
  # todo: loop again for all new facts. requires refactor!
  # loop over facts, not conditions...
  = rule
  call mergeFacts(facts, evalConditions(rule[0], rule[1], facts))
}
for rule in (rules) {
  # todo facts per choice!
  # todo: loop again for all new facts. requires refactor!
  # loop over facts, not conditions...
  call mergeFacts(facts, evalConditions(rule[0], rule[1], facts))
}
= facts
