#!/usr/bin/env ysh

var DEBUG = false
proc debug {
  if (DEBUG) {
    echo DEBUG - @[ARGV]
  }
}
proc debug-val (name;val) {
  if (DEBUG) {
    echo DEBUG $name - $(pp value (val))
  }
}
func mergeFacts (dst, src) {
  debug-val src (src)
  debug-val dst (dst)
  for key, val in (src) {
    case (type(dst=>get(key))) {
      Null { setvar dst[key] = val }
      List {
        for i in (val) {
          debug-val dst (dst[key])
          debug-val val (val)
          if (dst[key]=>indexOf(i) === -1) {
            debug-val target (dst[key])
            debug-val source (val)
	          call dst[key]->append(i)
            debug-val merged-target (dst[key])

	        }
        }
      }
    }
  debug-val src (src)
  debug-val dst (dst)
  }
}

# a list of facts, against which the current needs to be checked
var facts = []

# predicates and their possible arguments
# TODO: predicates might be variable length?
var facts = {}
var rules = []

# a list of predicates and they're current choices
var current_set = {}

proc - {
  var predicate = ARGV[0]
  assert [len(ARGV) > 1]
  if (facts=>get(predicate) !== null) {
    call facts[predicate]->append(ARGV[1:])
  } else {
    setglobal facts[predicate] = [ARGV[1:]]
  }
}
proc WHEN {
  var pred = []
  var conditions = [] # [['edge', 'Y', 'X'], ... ]
  var facts = []
  for i, arg in (ARGV) {
    if (arg === 'THEN') {
      var point = i+1
      break
    }
    if (arg === 'AND') {
      call conditions->append(pred)
      setvar pred = []
      continue
    }
    call pred->append(arg)
  }

  call conditions->append(pred)
  setvar pred = []
  for i, arg in (ARGV[point:]) {
    if (arg === 'AND') {
      call facts->append(pred)
      setvar pred = []
      continue
    }
    call pred->append(arg)
  }
  call facts->append(pred)
  call rules->append([conditions, facts])
  debug-val " rules" (rules)
}

# cond -> Condition to be evaluated [[[COND1][COND2]], [[FACT1],[FACT2]]]
# facts -> Existing facts [[FACT],[FACT],...]
# pred -> List of already defined predicates to meet condition
func evalConditions(conditions, truths, facts,...args) {
  var placeholders = {}
  var param
  debug-val conditions (conditions)
  debug-val args (args)
  debug-val facts (facts)
  for num_pred, arg in (args) {
    assert [len(conditions[num_pred]) === len(arg)+1] # args need to match
    debug-val rule (conditions[num_pred])
    for i, arg in (arg) {
      setvar param = conditions[num_pred][i+1]
      debug-val placeholders (placeholders)
      debug-val arg (arg)
      debug-val param (param)
      if (placeholders=>get(param) is not null) {
        if (arg !== placeholders[param]) {
      	  debug doesnt match:
	        debug-val "condition" (conditions[num_pred])
	        debug-val "arg" (arg)
          debug-val 'placeholders' (placeholders)
	        return ({})
      	}
      } else {
        setvar placeholders[param] = arg
     	}
    }
  }
  var new_facts = {}
  debug-val nnew_facts (new_facts)
  if (len(args) < len(conditions)) {
    debug-val "predicate of cur cond" (conditions[len(args)][0])
    # Loop over all facts we have for the args. Use it as argument
    for f in (facts=>get(conditions[len(args)][0], [])) {
      debug-val new_facts (new_facts)
      debug-val args (args ++[f])
      call mergeFacts(new_facts, evalConditions(conditions, truths,facts, ...args, f))
      debug-val 'new_facts after merge' (new_facts)

    }
  } else {
    #echo 'add placeholders!'
    debug-val placeholders (placeholders)
    debug-val truths (truths)
    var fact
    for truth in (truths) {
      setvar fact = []
      for param in (truth[1:]) {
        call fact->append(placeholders[param])
      }
      if (get(new_facts, truth[0]) is not null) {
        call new_facts[truth[0]]->append(fact)
      } else {
        setvar new_facts[truth[0]] = [fact]
      }
    }
  }
  debug-val "nnnew facts" (new_facts)
  return (new_facts)
}

source $[ARGV[0]]
debug-val 'all facts' (facts)
for rule in (rules) {
  # todo facts per choice!
  # todo: loop again for all new facts. requires refactor!
  # loop over facts, not conditions...
  = rule
  call mergeFacts(facts, evalConditions(rule[0], rule[1], facts))
}
for rule in (rules) {
  # todo facts per choice!
  # todo: loop again for all new facts. requires refactor!
  # loop over facts, not conditions...
  call mergeFacts(facts, evalConditions(rule[0], rule[1], facts))
}
= facts
