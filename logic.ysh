#!/usr/bin/env ysh

var DEBUG = false
setglobal ENV.FACTFD = $(mktemp facts.XXX)
setglobal ENV.NEWFD = $(mktemp newfacts.XXX)
proc debug {
  if (DEBUG) {
    echo DEBUG - @[ARGV] >&2
  }
}
proc debug-val (name;val) {
  if (DEBUG) {
    echo DEBUG $name - $(pp value (val)) >&2
  }
}
func mergeFacts (dst, src) {
  debug-val src (src)
  debug-val dst (dst)
  for fact in (src) {
    if (dst=>indexOf(fact) === -1) {
      call dst->append(fact)
    }
  }
  debug-val src (src)
  debug-val dst (dst)
}

# a list of facts, against which the current needs to be checked
var facts = []
var rules = []

# a list of predicates and they're current choices
var current_set = {}

proc - (...ARGV;;fd=ENV.FACTFD) {
  var predicate = ARGV[0]
  assert [len(ARGV) > 1]
  debug-val "checking fact" (ARGV)
  if (facts=>indexOf(ARGV) === -1) {
    debug-val "new fact" (ARGV)
    call facts->append(ARGV)
    debug-val "writing fact to" (fd)
    write $(json write (ARGV) | tr -d '\n') >> $fd
  }
}

proc WHEN {
  var pred = []
  var conditions = [] # [['edge', 'Y', 'X'], ... ]
  var truths = []
  for i, arg in (ARGV) {
    if (arg === 'THEN') {
      var point = i+1
      break
    }
    if (arg === 'AND') {
      call conditions->append(pred)
      setvar pred = []
      continue
    }
    call pred->append(arg)
  }

  call conditions->append(pred)
  setvar pred = []
  for i, arg in (ARGV[point:]) {
    if (arg === 'AND') {
      call truths->append(pred)
      setvar pred = []
      continue
    }
    call pred->append(arg)
  }
  call truths->append(pred)
  for condition in (conditions) {
    call rules->append([conditions, truths])
    setvar conditions = [conditions[-1]] ++ conditions[:-1]
  }
  debug-val " rules" (rules)
}

# cond -> Condition to be evaluated [[[COND1][COND2]], [[FACT1],[FACT2]]]
# facts -> Existing facts [[FACT],[FACT],...]
# pred -> List of already defined predicates to meet condition
func evalConditions(conditions, truths, facts,...args) {
  var placeholders = {}
  var param
  debug-val conditions (conditions)
  debug-val args (args)
  debug-val "current facts" (facts)
  for num_pred, arg in (args) {
    assert [len(conditions[num_pred]) === len(arg)] # args need to match
    debug-val rule (conditions[num_pred])
    # check conditions/fill in placeholders.
    # TODO: pass down (by copy)
    for i, val in (arg[1:]) {
      setvar param = conditions[num_pred][i+1]
      debug-val placeholders (placeholders)
      debug-val val (val)
      debug-val param (param)
      if (placeholders=>get(param) is not null) {
        if (val !== placeholders[param]) {
      	  debug doesnt match:
	        debug-val "condition" (conditions[num_pred])
	        debug-val "val" (val)
          debug-val 'placeholders' (placeholders)
	        return ([])
      	}
      } else {
        setvar placeholders[param] = val
     	}
    }
  }
  var new_facts = []
  # Not all conditions are met yet
  if (len(args) < len(conditions)) {
    # Loop over all facts we have for the args. Use it as argument
    for f in (facts) {
      # only use fact if it matches predicate
      # of next unmet condition
      if (f[0] !== conditions[len(args)][0]) {
        continue
      }
      debug-val "new arg" ([f])
      call mergeFacts(new_facts, evalConditions(conditions, truths,facts, ...args, f))
      debug-val 'new_facts after merge' (new_facts)

    }
  } else {
    #echo 'add placeholders!'
    debug-val placeholders (placeholders)
    debug-val truths (truths)
    var fact
    for truth in (truths) {
      debug-val "truth" (truth)
      setvar fact = [truth[0]]
      for param in (truth[1:]) {
        # TODO: Only use placeholder if capitalized
        call fact->append(placeholders[param])
      }
      debug-val "new fact" (fact)
      call new_facts->append(fact)
    }
  }
  debug-val "new facts" (new_facts)
  return (new_facts)
}

source $[ARGV[0]]
debug-val 'all facts' (facts)
#for rule in (rules) {
#  # todo facts per choice!
#  # todo: loop again for all new facts. requires refactor!
#  # loop over facts, not conditions...
#  = rule
#  call mergeFacts(facts, evalConditions(rule[0], rule[1], facts))
#}
var children = []
for rule in (rules) {
  # todo facts per choice!
  # todo: loop again for all new facts. requires refactor!
  # loop over facts, not conditions...
  fork {
    tail -f -n +0 $[ENV.FACTFD] | {
      var facts = []
      while (true) {
        try { read --raw-line (&line) }
        if (_error.code === 1) {
          break
        }
        write $line | json read (&fact)
        debug "rule got new fact"
        debug-val rule (rule)
        debug-val fact (fact)
        call facts->append(fact)
        # If predicate of first condition and fact are the same, do a loop
        # with all the currently known facts
        debug-val fact (fact)
        debug-val "first condition" (rule[0][0])
        if (fact[0] === rule[0][0][0]) {
          var new_facts = evalConditions(rule[0], rule[1], facts, fact)
          debug-val "New facts to add to global" (new_facts)
          for fact in (new_facts) {
            - @fact (fd=ENV.NEWFD)
          }
        }
      }
    }
  }
  call children->append($!)
}
debug-val "FACTFD" (ENV.FACTFD)
  # TODO: tail -f
  while (true) {
    # TODO: while woeking children
    sleep 2
    try { read --raw-line (&line) }
    if (_error.code === 1) {
      break
    }
    debug "Generated fact: $line"
    write $line | json read (&fact)
    - @fact (fd=ENV.FACTFD)
  } < $[ENV.NEWFD]
# TODO: wait for all processes to finish with some kind of semaphore
for child in (children) {
  kill $child
}
= facts
rm $[ENV.FACTFD] $[ENV.NEWFD]

