#!/usr/bin/env ysh

var port = 8080

rm -f http
mkfifo http

source --builtin ysh/args.ysh

parser (&spec) {
  flag -v --verbose
  arg directory (help='Directory to serve files in', default="./")
  flag -r --return (help="return the request")
}

setglobal arg = parseArgs(spec, ARGV)

proc log {
  if (arg.verbose) {
    write --end '' u'\u{1B}[31m' "$[ARGV =>join()=>trimEnd($'\n')]" u'\u{1B}[0m' >&2
  }
}

# http uses \r\n
proc hwrite {
  log @ARGV
  write "$[ARGV=>join()]"
}

var first_reg = / <capture ![ space ]+ as type> space <capture ![ space ]+ as slug> space 'HTTP/1.1' .*/
var header_reg = / <capture ![ ':' ]+ as key> ': ' <capture .+ as value> /

typed proc parse_header (;out) {
  var h = {}
  read first
  var raw = first ++ $'\r\n'
  if (first ~ first_reg) {
    setvar h.type = _group('type')
    setvar h.slug = _group('slug')
  } else {
    echo 'not an accepted HTTP Header!'>&2
    return
  }
  var c = 0
  while read line {
    if (len(line) < 2) {
     break
    }

    setvar raw = raw ++ line ++ $'\r\n'
    # assert might be a bit aggressive :shrug:
    # but it might get us the _group :)
    assert (line ~ header_reg)
    setvar h[_group('key')] = _group('value')
    # "security"
    assert [c < 100]
    setvar c += 1
  }
  call out->setValue([raw, h])
}

typed proc parse_body (;header, out) {
  if (header=>get('Content-Length', 0) === 0) {
    call out->setValue('')
    return 0
  }
  read -n $[header['Content-Length']]
  call out->setValue(_reply)
}

proc return_request () {
  # TODO: make a function which takes io
  parse_header (&header)
  parse_body (header[1], &body)
  var message = header[0] ++ body

  hwrite 'HTTP/1.1 200 OK'
  hwrite "Content-Length: $[len(message)+1]"
  hwrite ''
  log $message
  write $message
}

proc write-404 () {
  hwrite 'HTTP/1.1 404 File not found'
  hwrite "Content-Length: 0"
  hwrite ''

}

proc write-file (file) {
  if ! test -f $file {
    log "$file not found"
    write-404
    return
  }
  var size = $(stat --printf="%s" $file)
  hwrite 'HTTP/1.1 200 OK'
  hwrite "Content-Type: $(file -b --mime-type $file)"
  hwrite "Content-Length: $[size]"
  hwrite ''
  log "*return $file*"
  cat $file
}

proc return-file () {
  # TODO: make a function which takes io
  parse_header (&header)
  parse_body (header[1], &body)
  var header = header[1]
  assert [(header.slug ~ / %start '/' [ w '/' ]* / )]
  var p = arg.directory ++ header.slug
  if (p ~ / '/' %end /) {
    if test -d $p {
      if test -f $[p ++ "index.html"] {
        write-file $[p ++ "index.html"]
      }
    #TODO: index or 404
    }
  } else {
    write-file $p
  }
}

proc handle-req {
  if (arg.return) {
    nc -l -k -p $port < http | \
      { while (true) { return_request } > http; read < http }
  } else {
    nc -l -k -p $port < http | \
      { while (true) { return-file } > http; read < http }
  }
}


trap ' rm http' EXIT SIGINT
handle-req

