#!/usr/bin/env ysh
#
# Model - View - Update : But in Shell
# Effects are Commands which are executed in the background
# Ref: https://oils.pub/release/0.37.0/doc/ref/chap-type-method.html#Command
# The stdout of an effect goes to a FIFO which is read by the event loop
# it expects a JSON string which is passed to the `update` func, together with a `model`
# The model is initially defined by the `init` function, which returns a `model` and a first `effect`
# The eventloop calls the `view` proc and passes the `model` to render the output.
# Since the `view` forks, it can't update the `model`.
# Builtin Messages:
# Character input: {type: "input", char}
# Somewhat acurate (millisecond?) Ticks: TODO
# Signals: TODO
# Terminal Resize: TODO
#
# TODO: Convert into a module that takes an `object` which has init, update and view props

# Helper function that listens to keypresses and converts them into messages
proc input-to-message(listener, source) {
  fork {
    redir >> $listener {
      while (true) {
        var char = ''
        var chars = ''
        try {
          IFS= read -sn 1 char 2>/dev/null
        }
        if failed {
          # TODO: Message that source closed?!
          break
        }
        # Try to read as much as possible
        try {
          IFS= read -t 0 chars 2>/dev/null
        }
        # TODO: Translate ble.sh src/decode.sh key decoding
        # Sometimes this randomly hangs. Unclear why
        message ({src: source, type: "input", char: char ++ chars})
      }
    }
  }
}

# Retuen a command for which output is sent back as messages
proc wrapped-command (source;var;;block) {
  call var->setValue(^(
  var listener = $(mktemp --tmpdir -u)
  mkfifo $listener
  fork {
    redir <$listener {
      input-to-message $LISTENER $source
      #var out
      #while (true) {
      #  try { IFS= read -rn 1 out }
      #  if failed { break }
      #  if (len(out) > 0) {
      #    message ({type: "input", src: source, char:out})
      #  }
      #  setvar out = ''
      #}
    }
  }

  try {
    # TODO: STDERR seperately!
    redir 2>>$listener >>$listener { call io->eval(block) }
  }
  message ({type: "commandFinished", source, error: _error })
  rm $listener
  ))
}
proc message (;message) {
  # ensure we write to the right place!
  redir >> $LISTENER {
    # we need to fork, because it sometimes hangs
    # I suspect a bug on android with fifos
    fork { json write (message, space=0) }
  }
}

# setup and eventloop
proc run() {
  stty -echo
  setglobal LISTENER = $(mktemp --tmpdir -u msgs.XXXXX)
  # TODO: This could also be a plain file and a `tail -f` process could read it
  mkfifo $LISTENER
  trap "rm $LISTENER" EXIT INT

  var model
  var msg
  var effect

  # run init function
  # TODO: Pass arguments
  setvar model, effect = init()
  fork { input-to-message $LISTENER keyboard }

  exec </dev/null

  while (true) {
    # expect the model & a expression
    if (effect is not null) {
      fork {
        redir >> $LISTENER {
          call io->eval(effect)
        }
      }
    }
    # forkwait to ensure the view can't edit the model!
    if (model is not null) {
      forkwait { view (model) }
    }

    redir < $LISTENER {
      read --raw-line (&msgstring)
    }
    # TODO: vibdecode netstring library
    setvar msg = fromJson(msgstring)

    redir > /dev/null {
      setvar model, effect = update(model, msg)
    }
  }
}

var __provide__ = :| run |

# Example
# -------
# Prints seconds since program start (more or less) + the last pressed key

#func init() {
#  return ([
#    {n: 0, i:"Press a key!"}, # number and input
#    ^(sleep 1; json write ({type: "tick"}, space=0)) # message
#  ])
#}
#
#func update(model, msg) {
#  if (msg.type === "tick") {
#    setvar model.n += 1
#    return ([model, ^(sleep 1; json write ({type: "tick"}, space=0))])
#  }
#  if (msg.type === 'input') {
#    if (msg.char === u'\n' or msg.char === u'\r' or msg.char === u'\f' or msg.char === '') {
#      setvar model.i = 'newline and clearline characters are forbidden'
#      return ([model, ^()])
#    }
#    setvar model.i = msg.char
#    return ([model, ^()])
#  }
#
#}
#
#proc view (;model) {
#  # clear the line
#  write -n u'\u{1b}[2K\r'
#  # print the tick followed by the last pressed character
#  write -n "$[model.n] $[model.i]"
#}

#run
