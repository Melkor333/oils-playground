#!/usr/bin/env ysh
proc input-to-message(listener) {
  stty -echo
  fork {
    redir > $listener {
    while (true) {
      read -n 1 char
      json write ({type: "input", char}, space=0)
    }
    }
  }
}

proc run() {
  var listener = $(mktemp --tmpdir -u msgs.XXXXX)
  # TODO: trap to cleanup
  mkfifo $listener
  trap "rm $listener; stty echo" EXIT
  var model
  var msg
  var effect

  # run init function
  init (&model, &effect)
  fork { input-to-message $listener }

  while (true) {
    # expect the model & a expression
      fork {
    redir > $listener {
        call io->eval(effect)
      }
    }
    # TODO: make sure the model is a copy?
    view (model)

    redir < $listener {
      read --raw-line (&msgstring)
    }
    # TODO: vibdecode netstring library
    setvar msg = fromJson(msgstring)

    setvar model, effect = update(model, msg)
  }
}

# example
proc init (;model, effect) {
  call model->setValue({n: 0, i:""})
  call effect->setValue(^(sleep 1; json write ({type: "tick"}, space=0)))
}

func update(model, msg) {
  if (msg.type === "tick") {
    setvar model.n += 1
    return ([model, ^(sleep 1; json write ({type: "tick"}, space=0))])
  }
  if (msg.type === 'input') {
    setvar model.i = msg.char
    return ([model, ^()])
  }

}

proc view (;model) {
  write -n u'\u{1b}[2K\r'
  write -n "$[model.n] $[model.i]"
}

run
