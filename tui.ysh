var TERM_CR  = u'\u{0D}'
var TERM_ESC = u'\u{1B}'
var line_clear_key = $(tput el)
# Get terminal size ('stty' is POSIX and always available).
# This can't be done reliably across all bash versions in pure bash.
# TODO: hook to update on change
read -r TERM_HEIGHT TERM_WIDTH < <(stty size)
var TERM_CSI = "$TERM_ESC["
var COL = {
  none: "${TERM_CSI}0m",
  black: "${TERM_CSI}31m",
  red: "${TERM_CSI}31m",
  green: "${TERM_CSI}32m",
  yellow: "${TERM_CSI}33m",
  blue: "${TERM_CSI}34m",
  magenta: "${TERM_CSI}35m",
  cyan: "${TERM_CSI}36m",
  white: "${TERM_CSI}37m",
  default: "${TERM_CSI}39m",
}

func run_csi (...ARGV) {
  var self = _escapes # should be an input
  var comm = self[ARGV[0]]
  if (type(comm) === "Str") {
    return (comm)
  } else {
    if (len(ARGV)>1) {
      return (evalExpr(comm, pos_args=ARGV[1:]))
    } else {
      return (evalExpr(comm))
    }
  }
}

# TODO: Make Object(null, { ... })
# to allow inspection!
var _escapes = {
  __invoke__: run_csi,
  scroll_limit: ^["${TERM_CSI}$1;$2r"],
  scroll_reset: "{TERM_CSI};r",
  terminal_save: "${TERM_CSI}?1049h",
  terminal_restore: "${TERM_CSI}?1049l",
  cursor_hide: "${TERM_CSI}?25l",
  cursor_show: "${TERM_CSI}?25h",
  line_clear: line_clear_key,
  linewrap_disable: "${TERM_CSI}?7l",
  linewrap_enable: "{TERM_CSI}?7h",
  cursor_pos: ^["${TERM_CSI}$1;$2H"],
  erase_below: "${TERM_CSI}0J"
  erase_above: "${TERM_CSI}1J"
  erase_display: "${TERM_CSI}2J"
  height: TERM_HEIGHT,
  width: TERM_WIDTH,
}

# see https://en.m.wikipedia.org/wiki/Box-drawing_characters
# l -> left
# u -> up
# r -> right
# d -> down
#
# l -> normal
# ll -> dashed
# L -> fat
# LL -> double
# Ll -> fat dashed
var borders = {
  lr: "─",
  llrr: "┄",
  LR: "━",
  ud: "│",
  uudd: "┆",
  UD: "┃",
  rd: "┌",
  ld: "┐",
  ur: "└",
  ul: "┘",
}

setglobal _cursor_saves = []
proc save-cursor() {
    read -r h w < <(stty size)
    call _cursor_saves->append([h,w])
}

proc restore-cursor() {
  var h, w = _cursor_saves->pop()
  write --end '' $[run_csi('cursor_pos',h,w)]
}

proc get-dimensions() {
  read -r h w < <(stty size)
  setglobal TERM_HEIGHT = h
  setglobal TERM_WIDTH = w
}

get-dimensions
trap get-dimensions SIGWINCH

setglobal LAST_LOG_LENGTH = 0
proc log-with-footer (log, ...footer) {
  ### Log a line to stdout but retain the last FOOTER_LINES lines
  #save-cursor
  var footer_lines = []
  for line in (footer) {
    setvar footer_lines = footer_lines ++ line=>split(u'\n')
  }

  #echo $[height - LAST_LOG_LENGTH]
  write -n $[run_csi('cursor_pos',TERM_HEIGHT - LAST_LOG_LENGTH + 1,0)]
  write -n $[run_csi('linewrap_disable')]
  write $log
  var lines = len(footer_lines)
  for i, line in (footer_lines) {
    write $[run_csi('line_clear')]
    if (i === lines-1) {
      write -n $line
      continue
    }
    if (len(line) >= TERM_WIDTH) {
      write $[line[:TERM_WIDTH]]
    } else {
      write $line
    }
  }
  #echo OK3
  #restore-cursor
  setglobal LAST_LOG_LENGTH = lines
}

proc write-box-border(initheight, initwidth, height, width) {
  write -n $[run_csi('cursor_pos', initheight, initwidth)]
  var h = initheight
  var w = initwidth

  write --end $[borders.rd]
  for i in (0..<width) {
    write --end '' $[borders.lr]
  }
  write --end $[borders.ld]

  for i in (0..<height) {
    setvar h += 1
    write -n $[run_csi('cursor_pos',h,w)]
    write --end '' $[borders.ud]
    write -n $[run_csi('cursor_pos',h,w+width+1)]
    write --end '' $[borders.ud]
  }

  setvar h += 1
  write -n $[run_csi('cursor_pos',h,w)]
  write --end $[borders.ur]
  for i in (0..<width) {
    write --end '' $[borders.lr]
  }
  write --end $[borders.ul]
}

# Detect length of each character and split a string into chunks of same length.
# Required for vertically fill a box
# TODO: UTF-8, newlines and escape sequences have variable length!
# See e.g. ble.sh or tmux code
#func split-by-length(s, width, max) {
# var i = 0
# while (i<
#
#}

# TODO: the boxfill should ignore (and remove certain) escapes)
proc write-box-text(x, y, h, w, text;cut=true) {
  var t = []
  var tlen = len(text)
  if (cut) {
    for i, line in (text=>split(\n)) {
      if (len(line) < w) {
        call t->append(line)
      } else {
        call t->append(line[:w])
      }
      if (i >= h-1) { break }
    }
  } else {
    call t->append("Not implemented")
  }
  write -n $[run_csi('cursor_pos',x+1,y+1)]
  for i, line in (t) {
    write --end '' $line
    write -n $[run_csi('cursor_pos',x+i+2, y+1)]
  }
}

# legacy
proc write-box (x, y, w, h, t) {
  write-box-border $x $y $w $h
  write-box-text $x $y $w $h $t
    write -n $[run_csi('cursor_pos',x+h+1,0)]
}

# TODO: export them
setglobal NO_WRAP = 0
setglobal DUMB_WRAP = 1
setglobal WRAP = 2

## inputs:
## string
## int
## int
## wrap: NO_WRAP, DUMB,
## wrap options:
## outputs:
## [lines]
# TODO: align, center, top, left, ... like CSS
# TODO: border and border_style (taking a list)
# TODO: styling -> to ensure each line is styled individually
# TODO: `scroll` variable
# TODO: Allow passing a `[lines]` object
# TODO: only split on breakable characters
# TODO: Wrap vs nowrap
func paragraph(text, width, height, wrap=DUMB_WRAP) {
  if (wrap === NO_WRAP) {
    var lines = text.split(\n)
  }
  var out = []
  if (wrap === NO_WRAP) {
    for line in (lines) {
      var line_length = len(line)
      # TODO: Use length calculator from ble.sh src/canvas.sh ble/utils/s2w
      # line is longer than width
      if (line_length > width) {
        call out->append(line[:width])
      } elif (line_length !== width) {
        # right pad
        # TODO: only part of rendering? -> yes if spans!
        printf -v l "%s%$[width-line_length]s" $line ""
        call out->append(lines[c] = l)
      } else {
        call out->append(lines[c] = line)
      }
    }
  }

  # Fill rest of the rectangle.
  # TODO: should this only be a part of rendering? -> yes if we store string size (e.g. add `span` objects)
  printf -v l "%${width}s" ""
  for _ in (len(out)..<height) {
    call out->append(l)
  }
  return (out)
}

setglobal LAST_RENDER_LENGTH = 0
proc render-view (view;;vertical_bound="t", cursor_hidden=false) {
  ### redraw and write the view
  var lines = view=>split(u'\n')
  var line_count = len(lines)

  if (not cursor_hidden) {
    write -n $[run_csi('cursor_hide')]
  }
  # if we're bottom bound, we only go  to the
  if (vertical_bound !== "t") {
    write -n $[run_csi('cursor_pos', TERM_HEIGHT - line_count + 1, 0)]
  } else {
    write -n $[run_csi('cursor_pos', TERM_HEIGHT - LAST_RENDER_LENGTH + 1, 0)]
  }
  write -n $[run_csi('erase_below')]
  write -n $[run_csi('linewrap_disable')]
  write --end '' $view
  if (not cursor_hidden) { write -n $[run_csi('cursor_show')] }
  setglobal LAST_RENDER_LENGTH = line_count
}

# out: [[x, y, width, height],[x, y, width, height]]
func verticalSplit(x=0, y=0, width=TERM_WIDTH, height=TERM_HEIGHT, ratio=0.5) {
  return ([[x, y, int(width*ratio), height], [x+int(width*ratio)+1, y, width-int(width*ratio), height]])
}

# out: [[x, y, width, height],[x, y, width, height]]
func horizontalSplit(x=0, y=0, width=TERM_WIDTH, height=TERM_HEIGHT, ratio=0.5) {
  var firstHeight = int(height*ratio)
  return ([[x, y, width, int(height*ratio)], [x+int(width*ratio)+1, y, width-int(width*ratio), height]])
}

## TODO:
# proc render
# [[line, length]], [[[start, end, startchar, endchar]]]

var __provide__ = :| paragraph render-view run_csi |
